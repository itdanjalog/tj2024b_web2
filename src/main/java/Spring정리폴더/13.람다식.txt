[ 람다식 ]
1.정의
람다식은 익명 함수(anonymous function)를 간결하게 표현하는 방식입니다.
즉, 메서드 없이도 함수를 구현할 수 있는 기능으로, 자바 8부터 도입되었습니다.

2.목적
람다식은 코드의 가독성을 높이고, 간결하게 표현하기 위해 사용됩니다.
기존의 익명 클래스와 비교했을 때 불필요한 코드 제거와 가독성 향상이 주요 목적입니다.
코드 길이 단축 (불필요한 implements 및 override 제거)
가독성 향상 (간단한 연산을 한 줄로 표현)
병렬 처리 및 스트림 API와 결합 가능 (자바의 Stream API 활용)
익명 객체 생성 및 이벤트 리스너 간편화 (GUI 프로그래밍 시 유용)

3. 장단점
✅ 장점
✔ 코드가 간결함 → 불필요한 클래스를 만들 필요 없음
✔ 가독성이 높음 → 코드가 짧아지고, 핵심 로직이 직관적임
✔ 익명 함수의 활용 증가 → 메서드를 재사용할 필요 없이 즉석에서 정의 가능
✔ 병렬 처리에 적합 → 자바의 Stream API 및 멀티스레딩과 결합 가능
❌ 단점
✖ 디버깅이 어려움 → 오류 발생 시 스택 트레이스를 이해하기 어려울 수 있음
✖ 코드가 너무 짧아질 경우 가독성 저하 가능
✖ 인터페이스에 하나의 추상 메서드만 있어야 함 (함수형 인터페이스만 사용 가능)


4. 주요 함수형 인터페이스 정리
자바에서는 람다식을 활용하기 위해 기본적인 함수형 인터페이스를 제공합니다.
대표적으로 java.util.function 패키지에서 제공하는 4가지 인터페이스가 있습니다.
인터페이스	메서드	설명
Function<T, R>	apply(T t)	입력값 T를 받아서 결과값 R을 반환
Predicate<T>	test(T t)	조건을 검사하여 true 또는 false 반환
Consumer<T>	accept(T t)	값을 받아서 소비 (리턴값 없음)
Supplier<T>	get()	값을 생성하여 반환 (입력값 없음)


[ 스트림 ]
정의
스트림(Stream)은 자바 8에서 도입된 기능으로, 데이터의 연속된 흐름을 처리하는 방식입니다.
배열 또는 컬렉션(Collection) 등의 데이터를 간결하고 효율적으로 다룰 수 있도록 도와줍니다.

목적
데이터 처리 간결화: 기존의 반복문을 사용한 코드보다 가독성이 높아집니다.
함수형 프로그래밍 지원: 람다식과 결합하여 선언형 코드 스타일로 작성 가능
병렬 처리 지원: 쉽게 병렬 스트림(Parallel Stream)으로 변환하여 성능을 개선할 수 있음

3. 스트림의 특징
✅ 장점
✔ 원본 데이터 변경 없음 → 스트림은 데이터를 변경하지 않고, 변환된 새로운 데이터를 반환함
✔ 중간 연산과 최종 연산 분리 → 데이터 필터링, 매핑 후 원하는 결과를 얻는 구조
✔ 병렬 처리 가능 → parallelStream()을 사용하면 멀티코어 CPU 활용 가능
❌ 단점
✖ 한 번만 사용 가능 → 한 번 사용한 스트림은 재사용할 수 없음
✖ 디버깅 어려움 → 람다식과 결합되어 복잡한 경우 디버깅이 어려울 수 있음
✖ 지나친 사용 시 성능 저하 → 작은 데이터에서는 오히려 반복문보다 성능이 낮을 수 있음

4. 스트림의 주요 연산
스트림 연산은 **중간 연산(Intermediate Operation)**과 **최종 연산(Terminal Operation)**으로 나뉩니다.

✅ 중간 연산 (Intermediate Operation)
연산	설명	예제
filter(Predicate)	특정 조건을 만족하는 요소만 필터링	stream.filter(x -> x > 10)
map(Function)	각 요소를 변환하여 새로운 스트림 생성	stream.map(x -> x * 2)
sorted()	요소 정렬	stream.sorted()
distinct()	중복 제거	stream.distinct()
✅ 최종 연산 (Terminal Operation)
연산	설명	예제
forEach(Consumer)	각 요소에 대해 특정 연산 수행	stream.forEach(System.out::println)
count()	요소 개수 반환	long count = stream.count();
collect(Collector)	리스트, 세트 등으로 변환	stream.collect(Collectors.toList())
reduce(BinaryOperator)	스트림의 요소를 하나의 값으로 합침	stream.reduce(0, Integer::sum)

6. 스트림과 병렬 처리 (Parallel Stream)
**병렬 스트림(Parallel Stream)**을 사용하면 여러 개의 스레드를 활용하여 성능을 개선할 수 있습니다.
=======================================
1. 중간 연산 (Intermediate Operation)
중간 연산은 스트림의 데이터를 변경하거나 필터링하는 연산입니다.
중간 연산은 스트림을 반환하며, 즉시 실행되지 않습니다. 중간 연산은 여러 번 연결하여 사용할 수 있습니다.
스트림을 변환할 수 있지만, 실제로 변환이 이루어지는 것은 최종 연산이 호출될 때입니다.
filter(): 조건에 맞는 요소를 필터링
map(): 각 요소를 다른 형태로 변환
sorted(): 요소 정렬
distinct(): 중복 제거

2. 최종 연산 (Terminal Operation)
최종 연산은 스트림의 결과를 처리하거나, 스트림을 종료하는 연산입니다.
최종 연산이 호출되면 스트림은 실제 실행되며, 최종 결과를 반환하거나 특정 작업을 수행합니다.
한 번의 최종 연산이 호출되면 스트림은 더 이상 사용할 수 없습니다.
forEach(): 스트림의 각 요소에 대해 작업을 수행
collect(): 스트림의 요소들을 컬렉션으로 모음
count(): 스트림에서 요소의 개수를 셈
reduce(): 스트림의 요소들을 하나로 결합

중간 연산 vs 최종 연산
구분	중간 연산 (Intermediate Operation)	최종 연산 (Terminal Operation)
실행	지연 실행 (Lazy Evaluation)	즉시 실행 (Eager Evaluation)
반환값	스트림 반환	결과값 반환 (예: 컬렉션, 정수, 불린 등)
예시	filter(), map(), sorted()	forEach(), collect(), count()


==============================================
[ Optional ]
Optional 클래스는 Java 8에서 도입된 클래스이며, null 값을 안전하게 처리할 수 있도록 돕는 객체입니다. Optional을 사용하면 null 값을 직접 다루지 않고, null을 안전하게 처리할 수 있는 다양한 방법을 제공합니다. 이를 통해 NullPointerException을 예방하고 코드의 안정성과 가독성을 높이는 데 도움이 됩니다.

Optional 객체란?
Optional은 값이 있을 수도 있고 없을 수도 있는 상황을 나타내는 컨테이너입니다.
Optional<T>는 T 타입의 값을 포함할 수 있으며, 값이 없을 경우 Optional.empty()를 통해 비어있는 상태를 나타냅니다.
Optional은 직접적으로 null을 포함하지 않고, null을 안전하게 처리할 수 있는 방법을 제공합니다.

Optional을 사용하는 이유
null을 직접 다루지 않음으로써 NullPointerException을 방지할 수 있습니다.
코드의 의도를 더 명확하게 표현할 수 있습니다. 예를 들어, 메소드가 값을 반환할 수 있지만 없을 수도 있다는 것을 Optional로 나타낼 수 있습니다.
Optional은 값이 있는지 확인하거나 기본값을 제공하는 등의 작업을 메소드 체이닝으로 간결하게 처리할 수 있습니다.


Optional의 주요 메소드
of():

값이 null이 아니어야 할 때 Optional을 생성합니다.

값이 null이면 NullPointerException을 발생시킵니다.

예: Optional<String> opt = Optional.of("Hello");

ofNullable():

값이 null일 수도 있을 때 사용합니다.

값이 null이면 Optional.empty()를 반환합니다.

예: Optional<String> opt = Optional.ofNullable(null); // 값이 없으면 Optional.empty() 반환

empty():

비어있는 Optional 객체를 반환합니다. Optional.empty()는 값이 없는 경우를 나타냅니다.

예: Optional<String> opt = Optional.empty();

isPresent():

값이 존재하면 true를 반환하고, 값이 없으면 false를 반환합니다.

예: optionalStr.isPresent()가 true라면 값이 존재함을 의미합니다.

ifPresent():

값이 존재하면 해당 값에 대해 특정 작업을 실행합니다.

예: optionalStr.ifPresent(value -> System.out.println(value));

orElse():

값이 존재하면 해당 값을 반환하고, 없으면 지정한 기본값을 반환합니다.

예: optionalStr.orElse("Default Value");

orElseThrow():

값이 존재하면 해당 값을 반환하고, 없으면 예외를 던집니다.

예: optionalStr.orElseThrow(() -> new IllegalArgumentException("값이 없습니다!"));

get():

값이 존재하면 해당 값을 반환합니다. 값이 없으면 NoSuchElementException을 던집니다.

예: optionalStr.get()은 값이 없으면 예외가 발생하므로 사용 시 주의가 필요합니다.

map():

값이 존재하면 변환된 값을 반환하고, 값이 없으면 그대로 빈 Optional을 반환합니다.

예: optionalStr.map(String::toUpperCase)는 값이 있을 경우 대문자로 변환된 Optional을 반환합니다.

flatMap():

map()과 비슷하지만, map()은 반환된 값이 Optional일 경우 중첩된 Optional이 생깁니다. flatMap()은 이 중첩을 제거하여 하나의 Optional을 반환합니다.

예: optionalStr.flatMap(s -> Optional.of(s.toUpperCase()))

filter():

값이 존재하면 조건을 만족하는지 체크하고, 만족하면 값을 반환하며, 그렇지 않으면 빈 Optional을 반환합니다.

예: optionalStr.filter(s -> s.length() > 5)는 길이가 5 이상인 값만 반환합니다.

isEmpty() (Java 11부터 사용 가능):

값이 없으면 true, 있으면 false를 반환합니다.


========================================================
메소드 레퍼런스 (Method Reference) 정의
메소드 레퍼런스는 메소드 이름을 직접 참조하여 호출하는 기능입니다. Java 8에서 람다식을 더욱 간결하게 사용할 수 있게 도와주는 방법으로, 메소드를 참조하는 문법을 제공합니다. 람다식이 메소드의 구현을 표현하는 방식이라면, 메소드 레퍼런스는 이미 존재하는 메소드를 간단히 호출하는 방식입니다.

목적
코드의 가독성을 높이고, 반복적인 람다 표현식을 간결하게 작성할 수 있게 합니다.

기존에 작성된 메소드를 참조하는 방식으로, 코드 중복을 줄이고 명확하게 의도를 전달할 수 있습니다.

장점
간결하고 직관적인 코드: 메소드 레퍼런스는 람다식보다 코드가 간결하고 직관적으로 작성됩니다.

리팩토링 및 유지보수 용이: 이미 작성된 메소드를 재사용할 수 있어, 리팩토링을 쉽게 하고 코드 중복을 줄일 수 있습니다.

명확한 의도 표현: 메소드 이름을 직접 참조하기 때문에, 의도가 더 명확하게 드러납니다.

단점
메소드 참조가 복잡할 경우 이해하기 어려울 수 있음: 메소드 레퍼런스는 람다식을 단순화할 수 있지만, 복잡한 메소드 참조는 이해하기 어려운 경우가 있을 수 있습니다.

메소드의 시그니처가 일치해야 함: 메소드 레퍼런스는 참조하는 메소드의 시그니처가 인터페이스와 정확히 일치해야 하므로, 때로는 복잡한 형태로 사용되기도 합니다.

=======================================================
